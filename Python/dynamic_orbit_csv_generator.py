# -*- coding: utf-8 -*-
"""Dynamic_Orbit_CSV_Generator.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ijvanfykQMWWaZILotCvwjtQDyODX2FR

**Dynamic Orbit CSV Generator**

This notebook creates CSV files of stellar orbital positions in either a galactocentric or a heliocentric refrence frame.
"""

OBJECT_NAME = 'Orion_YSOs_Heliocentric'
FILE_LOCATION = 'drive/Shared drives/Owen/Orion_XYZ_UVW_200-800pc_YSOs_more-columns.fits'

REGRESSIVE   = True      # Are we simulating the past, instead of the future?
HELIOCENTRIC = True      # Is our frame of reference the sun, instead of the center of the galaxy?
SAMPLE_SIZE  = 10000     # How many stars are we sampling from our dataset?
TIMESPAN     = 20000000  # How many years are we simulating from the present?
TIMESTEP     = 100000    # How many years will each of our datapoints represent?

# Connect Google Colab to Google Drive
from google.colab import drive
drive.mount('/content/drive')

# Commented out IPython magic to ensure Python compatibility.
!pip -q install astropy
from astropy.io import fits
from astropy.table import Table
from astropy import units as u
from astropy import coordinates as coord
from astropy.coordinates import SkyCoord
from astropy.coordinates import LSR

!pip -q install galpy
import galpy
from galpy.orbit import Orbit
from galpy.potential import MWPotential2014

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import math
# %matplotlib inline

from google.colab import files

# Open the dataset and print each of its columns' types.
file = fits.open(FILE_LOCATION, memmap=False)
print(file.info(),'\n-----------\n',file[1].columns)

# Populate a dataframe with every valid star entry in the dataset.
df = pd.DataFrame({'ra':[], 'dec':[], 'distance':[], 'U':[], 'V':[], 'W':[]})
for star in file[1].data:
  if (np.isnan(star.field('U')) or np.isnan(star.field('V')) or np.isnan(star.field('W'))) == False:
    df = df.append({'ra':star.field('RA'),
                    'dec':star.field('DEC'),
                    'distance': (1/(star.field('plx')/1000)),
                    'U':star.field('U'),
                    'V':star.field('V'),
                    'W':star.field('W')},
                    ignore_index=True)

# Initialize an array of Orbit objects, starting with our Sun.
orbits = []
orbits.append(Orbit())
# Initialize each entry in our dataframe as an Orbit and populate the array.
for index, row in df.iterrows():
  o = Orbit(vxvv=[row['ra'] * u.deg,
                  row['dec'] * u.deg,
                  row['distance']/1000 * u.kpc,
                  row['U'] * u.km/u.s,
                  row['V'] * u.km/u.s,
                  row['W'] * u.km/u.s],
                  radec=True,
                  uvw=True,
                  solarmotion=u.Quantity([-LSR.v_bary.d_x, LSR.v_bary.d_y, LSR.v_bary.d_z]))
  orbits.append(o)

# Simulate each Orbit object by integration
ts = np.linspace(0,TIMESPAN,int(TIMESPAN/TIMESTEP)) * u.yr
for orbit in orbits:
  if (REGRESSIVE == True):
    orbit.flip(inplace=True)
  orbit.integrate(ts, MWPotential2014, method = 'dopr54_c')

file_index = int(TIMESPAN/TIMESTEP)-1 
# Extract and export each datapoint from the simulation as a .csv file. 
for t in range(0,TIMESPAN,TIMESTEP):
  df_temp = pd.DataFrame({'x coord':[], 'y coord':[], 'z coord':[]})
  for orbit in orbits:
    if (HELIOCENTRIC == True):
      df_temp = df_temp.append({'x coord':-1000*((orbit.x(t*u.yr)-orbits[0].x(t*u.yr))),
                                'y coord':1000*(orbit.y(t*u.yr)-orbits[0].y(t*u.yr)),
                                'z coord':1000*(orbit.z(t*u.yr)-orbits[0].z(t*u.yr))},
                                ignore_index=True)
    else:
      df_temp = df_temp.append({'x coord':-1000*orbit.x(t*u.yr),
                                'y coord':1000*orbit.y(t*u.yr),
                                'z coord':1000*orbit.z(t*u.yr)},
                                ignore_index=True)
  file_name = OBJECT_NAME + "." + str(file_index) + ".csv"
  df_temp.to_csv(path_or_buf=file_name, index=False)
  files.download(file_name)
  if (REGRESSIVE == True): file_index -= 1
  else: file_index += 1